<mxfile host="www.draw.io" modified="2019-12-04T10:40:07.098Z" agent="Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/78.0.3904.97 Safari/537.36" etag="aYSUJTGYwzt33-0-WDzw" version="12.3.5" type="github" pages="2">
  <diagram id="gzc1fXgGK9Xh2YCLqEI3" name="The Pretext">
    <mxGraphModel dx="1102" dy="533" grid="1" gridSize="10" guides="1" tooltips="1" connect="1" arrows="1" fold="1" page="1" pageScale="1" pageWidth="1920" pageHeight="1200" math="0" shadow="0">
      <root>
        <mxCell id="0"/>
        <mxCell id="1" parent="0"/>
        <mxCell id="4iyLbNcxx3MA4uBL4IOl-1" value="&lt;div style=&quot;text-align: center&quot;&gt;&lt;font style=&quot;font-size: 17px&quot;&gt;&lt;b&gt;Few basic Terminologies&lt;/b&gt;&lt;/font&gt;&lt;/div&gt;Pre-Texts:&amp;nbsp;&lt;br&gt;Frame Buffer: The Buffer which is displayed on display by the display hardware to manage this buffer usually frame buffer hardware are written.&lt;br&gt;&lt;br&gt;Display Control: The hardware unit which is responsible for controlling the display funcitons and more importantly generating the vertical sync and horizontal sync signals and these days mostly part of GPU. This is also responsible for video memory managment&lt;br&gt;&lt;br&gt;Common Colour Space schemes: RGB-CYMK&lt;br&gt;&lt;br&gt;EGL: An API interface b/w the rendering APIs like OpenGL or OpenVG and underlying native platform windowing systems.It is to be said as binding API for GL&lt;br&gt;&lt;br&gt;DRI: Direct rendering Infrastructure&amp;nbsp;is to access the graphics h/w under&amp;nbsp; X window system(X11 or moslty unix based). Master task is to provide acceleration to mesa implementation of OpenGL.&lt;br&gt;&lt;br&gt;DRM: Direct rendering Manager Linux Kernel&#39;s Graphic level component, Lib DRM is used from user space to talk to DRM and further DRM talks to video card and video card are usually present in GPU these days&lt;br&gt;&lt;br&gt;EGL and DRM connectivity: EGL is higher hierarchy used by application directly, Mesa or Mesa3D is open GL implementation it also has Vulcan and other Graphics API support, different OS implementation of these API are different but they follow a common APU spec. EGL acts as glue with app and these implementation&lt;br&gt;In Linux mesa3D has calls to DRM which further goes to Display through DRM&lt;br&gt;&lt;br&gt;" style="text;html=1;strokeColor=#000000;fillColor=none;align=left;verticalAlign=middle;whiteSpace=wrap;rounded=0;strokeWidth=1;spacingLeft=5;spacingBottom=0;spacingRight=5;" vertex="1" parent="1">
          <mxGeometry x="20" y="20" width="700" height="440" as="geometry"/>
        </mxCell>
        <mxCell id="4iyLbNcxx3MA4uBL4IOl-2" value="&lt;div&gt;&lt;span style=&quot;font-size: 17px&quot;&gt;&lt;b&gt;Scratching the Surface&lt;/b&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;Surface for US and all the affiliated buffers are allocated in the surface flinger and passed to UI app with through binder calls. Memory can be shared with help of ION or ashmem by sharing minimal details like file descriptors and all. This detail of how to share the buffers left on vendor implementation and varies accordingly. However Android defines the generic native graphic handles and vendor specific private handles extends this structure(native_handle_t) in gralloc.&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;AnativeWindowBuffer uses native_handle_t and its pointer format is type cast as buffer_handle_t. Hence, Native_Handle_t or BufferHandle_t is high level implementation for vendors to extend to implement graphic buffer packaging.&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;For fast traversal of object may happen over binder hence a class Flattenable is implemented.&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;Graphic Buffer class: Implementation of ANativeWindowBuffer in GraphicBuffer.h This also has inheritance form Flattenable&amp;nbsp; and also from refbase, ANAtiveObject and geometric//colour space.&lt;/div&gt;&lt;div&gt;The lock and unlock are used for mapping and unmapping of virtual adress and graphic buffer mapper is main workload forthis.&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;Surface.h: This feeds buffer to bufferqueue.h through aidl interface IGraphicBufferProducer&#39;s instance mGraphicBufferProducer&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;Last note before concluding this post, Surface uses a set of static hook methods to specify the callback function pointes in ANativceWindow&lt;br&gt;&lt;/div&gt;" style="text;html=1;strokeColor=#000000;fillColor=none;align=left;verticalAlign=middle;whiteSpace=wrap;rounded=0;" vertex="1" parent="1">
          <mxGeometry x="30" y="480" width="700" height="410" as="geometry"/>
        </mxCell>
        <mxCell id="4iyLbNcxx3MA4uBL4IOl-3" value="&lt;div style=&quot;text-align: center&quot;&gt;&lt;b style=&quot;font-size: 17px&quot;&gt;Relation of these Terms with Android Graphics&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b style=&quot;font-size: 17px&quot;&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;font style=&quot;font-size: 12px&quot;&gt;Android graphics runs on top of Linux&amp;nbsp;graphics, DRM and EGL but it does not include X11 which is remote n/w login services&lt;/font&gt;&lt;/div&gt;&lt;div&gt;&lt;font style=&quot;font-size: 12px&quot;&gt;&lt;br&gt;&lt;/font&gt;&lt;/div&gt;&lt;div&gt;&lt;font style=&quot;font-size: 12px&quot;&gt;Surface flinger provides the composite service, UI app does not draw to the frame buffer directly but does by obtaining a surface of depth form surface flinger.&lt;/font&gt;&lt;/div&gt;&lt;div&gt;&lt;font style=&quot;font-size: 12px&quot;&gt;From Ui&#39;s perspective surface is a rectangular canvas window on a screen with 2D geometrical metric and with a particular color scheme. The depth of the surface or the z-order is specified when the surface is obtained from ?&lt;/font&gt;&lt;/div&gt;&lt;div&gt;&lt;font style=&quot;font-size: 12px&quot;&gt;&lt;br&gt;&lt;/font&gt;&lt;/div&gt;&lt;div&gt;&lt;font style=&quot;font-size: 12px&quot;&gt;Surface flinger selects which surface has to be displayed partially or fully . The lower surfaces are not displayed on the screen. Surface flinger drives the composition of surface area and the rendering to the display screen.&lt;/font&gt;&lt;/div&gt;&lt;div&gt;&lt;font style=&quot;font-size: 12px&quot;&gt;&lt;br&gt;&lt;/font&gt;&lt;/div&gt;&lt;div&gt;&lt;font style=&quot;font-size: 12px&quot;&gt;The window in perspective of GUI and OS is visible window systems which is drawn by OS services on the screen, for example a split screen in android or windows can be considered as two windows which are drawn on the display at once. This is done by windowing manager in android. Ussauly a drawable window is defined by OS as its native window. Usually these window types are defined in EGL.&lt;/font&gt;&lt;/div&gt;&lt;div&gt;&lt;font style=&quot;font-size: 12px&quot;&gt;On Android The Abstract window prototype is defined in &lt;a href=&quot;https://android.googlesource.com/platform/system/core/+/7cd3e0a3a2f9b104cd6c04f699ae62c4577787e2/include/system/window.h&quot;&gt;window.h&lt;/a&gt;&amp;nbsp;with a structure name ANativeWindow. In android ANativeWindow is interchangebly use with EGLNativeWindowTpe.&lt;/font&gt;&lt;/div&gt;&lt;div&gt;&lt;font style=&quot;font-size: 12px&quot;&gt;&lt;br&gt;&lt;/font&gt;&lt;/div&gt;&lt;div&gt;&lt;font style=&quot;font-size: 12px&quot;&gt;A window is associated with certain count of graphic buffers which used to contain drawing artifacts.&lt;/font&gt;&lt;/div&gt;&lt;div&gt;&lt;font style=&quot;font-size: 12px&quot;&gt;&lt;br&gt;&lt;/font&gt;&lt;/div&gt;&lt;div&gt;&lt;font style=&quot;font-size: 12px&quot;&gt;Some more about ANativeWindow: it has set of static attributes as 2D resolutions&amp;nbsp; as well as dynamic ones such as scaling modes, transforms,buffer swap interval range, a collection of callback function pointers.&lt;/font&gt;&lt;/div&gt;&lt;div&gt;&lt;font style=&quot;font-size: 12px&quot;&gt;such as : Query() setSwapInterval() QueueBuffer() DequeueBuffer, canclebuffer. fenceFD is recently Added to support egl&#39;s extension of fence() APi. Another worth mentioning api is *perform() which is used to perform special action on the window like lock window, crop, setbuffer count using predefined macros like NATIVE_WINDOW_SET_USAGE.&lt;/font&gt;&lt;/div&gt;&lt;div&gt;&lt;font style=&quot;font-size: 12px&quot;&gt;&lt;br&gt;&lt;/font&gt;&lt;/div&gt;&lt;div&gt;&lt;font style=&quot;font-size: 12px&quot;&gt;ANativeWindow and ANativeWindowBUffer has a common field of type android_native_base_t for reference counting and checking&lt;/font&gt;&lt;/div&gt;" style="text;html=1;strokeColor=#000000;fillColor=none;align=left;verticalAlign=middle;whiteSpace=wrap;rounded=0;" vertex="1" parent="1">
          <mxGeometry x="740" y="21" width="710" height="440" as="geometry"/>
        </mxCell>
        <mxCell id="4iyLbNcxx3MA4uBL4IOl-4" value="Text" style="text;html=1;strokeColor=none;fillColor=none;align=center;verticalAlign=middle;whiteSpace=wrap;rounded=0;" vertex="1" parent="1">
          <mxGeometry x="150" y="910" width="40" height="20" as="geometry"/>
        </mxCell>
        <mxCell id="4iyLbNcxx3MA4uBL4IOl-5" value="Further more with flow chart" style="text;html=1;strokeColor=none;fillColor=none;align=center;verticalAlign=middle;whiteSpace=wrap;rounded=0;fontSize=16;fontStyle=1" vertex="1" parent="1">
          <mxGeometry x="880" y="570" width="270" height="70" as="geometry"/>
        </mxCell>
      </root>
    </mxGraphModel>
  </diagram>
  <diagram id="Q2kh0XxEFPfY4haGWi_g" name="Page1">
    <mxGraphModel dx="1102" dy="533" grid="1" gridSize="10" guides="1" tooltips="1" connect="1" arrows="1" fold="1" page="1" pageScale="1" pageWidth="1920" pageHeight="1200" math="0" shadow="0">
      <root>
        <mxCell id="K7Fy9GB3S_SE-LigXws0-0"/>
        <mxCell id="K7Fy9GB3S_SE-LigXws0-1" parent="K7Fy9GB3S_SE-LigXws0-0"/>
        <mxCell id="gDswjviEbk-ydCxPAqcq-6" value="" style="edgeStyle=orthogonalEdgeStyle;orthogonalLoop=1;jettySize=auto;html=1;fontSize=12;rounded=0;dashed=1;" edge="1" parent="K7Fy9GB3S_SE-LigXws0-1" source="gDswjviEbk-ydCxPAqcq-3" target="gDswjviEbk-ydCxPAqcq-5">
          <mxGeometry relative="1" as="geometry"/>
        </mxCell>
        <mxCell id="gDswjviEbk-ydCxPAqcq-3" value="&lt;b&gt;&lt;a href=&quot;https://android.googlesource.com/platform/frameworks/native/+/034bc1799cbbc4184aa507eba181573c0a3b9b35/include/gui/Surface.h&quot;&gt;Surface Class&lt;/a&gt;&lt;/b&gt;&lt;br&gt;&lt;font style=&quot;font-size: 11px&quot;&gt;An implementation of ANativeWindow that feeds graphics buffers into a BufferQueue&lt;/font&gt;" style="rounded=1;whiteSpace=wrap;html=1;strokeColor=#000000;strokeWidth=1;fontSize=16;align=center;" vertex="1" parent="K7Fy9GB3S_SE-LigXws0-1">
          <mxGeometry x="20" y="230" width="230" height="130" as="geometry"/>
        </mxCell>
        <mxCell id="gDswjviEbk-ydCxPAqcq-4" value="" style="group" vertex="1" connectable="0" parent="K7Fy9GB3S_SE-LigXws0-1">
          <mxGeometry x="20" y="20" width="260" height="180" as="geometry"/>
        </mxCell>
        <mxCell id="K7Fy9GB3S_SE-LigXws0-2" value="&lt;b&gt;GraphicBufferClass&lt;/b&gt;" style="rounded=1;whiteSpace=wrap;html=1;strokeColor=#000000;strokeWidth=1;fontSize=16;align=center;dashed=1;" vertex="1" parent="gDswjviEbk-ydCxPAqcq-4">
          <mxGeometry width="260" height="180" as="geometry"/>
        </mxCell>
        <mxCell id="gDswjviEbk-ydCxPAqcq-0" value="&lt;font style=&quot;font-size: 11px&quot;&gt;Flattenable&lt;/font&gt;" style="ellipse;whiteSpace=wrap;html=1;strokeColor=#000000;strokeWidth=1;fontSize=16;align=center;dashed=1;dashPattern=1 1;" vertex="1" parent="gDswjviEbk-ydCxPAqcq-4">
          <mxGeometry x="30" y="130" width="110" height="30" as="geometry"/>
        </mxCell>
        <mxCell id="gDswjviEbk-ydCxPAqcq-1" value="&lt;font style=&quot;font-size: 11px&quot;&gt;ANativeWindowBuffer&lt;/font&gt;" style="ellipse;whiteSpace=wrap;html=1;strokeColor=#000000;strokeWidth=1;fontSize=16;align=center;dashed=1;dashPattern=1 1;" vertex="1" parent="gDswjviEbk-ydCxPAqcq-4">
          <mxGeometry x="30" y="10" width="120" height="40" as="geometry"/>
        </mxCell>
        <mxCell id="gDswjviEbk-ydCxPAqcq-2" value="&lt;font style=&quot;font-size: 11px&quot;&gt;RefBase&lt;/font&gt;" style="ellipse;whiteSpace=wrap;html=1;strokeColor=#000000;strokeWidth=1;fontSize=16;align=center;dashed=1;dashPattern=1 1;" vertex="1" parent="gDswjviEbk-ydCxPAqcq-4">
          <mxGeometry x="140" y="50" width="100" height="20" as="geometry"/>
        </mxCell>
        <mxCell id="gDswjviEbk-ydCxPAqcq-7" value="" style="edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;dashed=1;fontSize=12;" edge="1" parent="K7Fy9GB3S_SE-LigXws0-1" source="gDswjviEbk-ydCxPAqcq-5" target="gDswjviEbk-ydCxPAqcq-3">
          <mxGeometry relative="1" as="geometry"/>
        </mxCell>
        <mxCell id="gDswjviEbk-ydCxPAqcq-5" value="For example, a video decoder could render a frame and call eglSwapBuffers(), which invokes ANativeWindow callbacks defined by Surface. Surface then forwards the buffers through Binder IPC to the BufferQueue’s producer interface, providing the new frame to a consumer such as GLConsumer.&amp;nbsp;" style="text;html=1;strokeColor=#000000;fillColor=none;align=center;verticalAlign=middle;whiteSpace=wrap;rounded=0;dashed=1;fontSize=12;glass=1;" vertex="1" parent="K7Fy9GB3S_SE-LigXws0-1">
          <mxGeometry y="410" width="280" height="150" as="geometry"/>
        </mxCell>
      </root>
    </mxGraphModel>
  </diagram>
</mxfile>
